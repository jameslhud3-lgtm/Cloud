<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #e0e0e0;
    }

    .game-container {
      text-align: center;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: #00d474;
      text-shadow: 0 0 10px rgba(0, 212, 116, 0.3);
    }

    .score-board {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin-bottom: 15px;
      font-size: 1.2rem;
    }

    .score-board span {
      color: #aaa;
    }

    .score-board .value {
      color: #fff;
      font-weight: bold;
    }

    canvas {
      border: 2px solid #00d474;
      border-radius: 4px;
      background: #16213e;
      display: block;
      margin: 0 auto;
      box-shadow: 0 0 20px rgba(0, 212, 116, 0.15);
    }

    .controls {
      margin-top: 15px;
      color: #888;
      font-size: 0.9rem;
    }

    .overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .overlay h2 {
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .overlay p {
      font-size: 1.1rem;
      color: #aaa;
    }

    .game-wrapper {
      position: relative;
      display: inline-block;
    }

    /* Mobile touch controls */
    .touch-controls {
      display: none;
      margin-top: 20px;
      user-select: none;
    }

    .touch-row {
      display: flex;
      justify-content: center;
      gap: 5px;
      margin: 5px 0;
    }

    .touch-btn {
      width: 60px;
      height: 60px;
      background: #16213e;
      border: 2px solid #00d474;
      border-radius: 8px;
      color: #00d474;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
    }

    .touch-btn:active {
      background: #00d474;
      color: #16213e;
    }

    .touch-spacer {
      width: 60px;
      height: 60px;
    }

    @media (pointer: coarse) {
      .touch-controls { display: block; }
      .controls { display: none; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>Snake</h1>
    <div class="score-board">
      <div><span>Score: </span><span class="value" id="score">0</span></div>
      <div><span>Best: </span><span class="value" id="best">0</span></div>
    </div>
    <div class="game-wrapper">
      <canvas id="game" width="400" height="400"></canvas>
    </div>
    <div class="touch-controls">
      <div class="touch-row">
        <div class="touch-spacer"></div>
        <button class="touch-btn" data-dir="up">&#9650;</button>
        <div class="touch-spacer"></div>
      </div>
      <div class="touch-row">
        <button class="touch-btn" data-dir="left">&#9664;</button>
        <button class="touch-btn" data-dir="down">&#9660;</button>
        <button class="touch-btn" data-dir="right">&#9654;</button>
      </div>
    </div>
    <div class="controls">
      Arrow keys or WASD to move &middot; Space to pause &middot; Enter to restart
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');

    const GRID = 20;
    const COLS = canvas.width / GRID;
    const ROWS = canvas.height / GRID;
    const BASE_SPEED = 130;
    const MIN_SPEED = 60;

    let snake, direction, nextDirection, food, score, bestScore, gameState, speed;

    bestScore = parseInt(localStorage.getItem('snakeBest') || '0', 10);
    bestEl.textContent = bestScore;

    function init() {
      const midX = Math.floor(COLS / 2);
      const midY = Math.floor(ROWS / 2);
      snake = [
        { x: midX, y: midY },
        { x: midX - 1, y: midY },
        { x: midX - 2, y: midY },
      ];
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      score = 0;
      speed = BASE_SPEED;
      scoreEl.textContent = score;
      placeFood();
      gameState = 'ready';
    }

    function placeFood() {
      let pos;
      do {
        pos = {
          x: Math.floor(Math.random() * COLS),
          y: Math.floor(Math.random() * ROWS),
        };
      } while (snake.some(seg => seg.x === pos.x && seg.y === pos.y));
      food = pos;
    }

    function update() {
      if (gameState !== 'playing') return;

      direction = { ...nextDirection };

      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y,
      };

      // Wall collision
      if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
        gameOver();
        return;
      }

      // Self collision
      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        gameOver();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        if (score > bestScore) {
          bestScore = score;
          bestEl.textContent = bestScore;
          localStorage.setItem('snakeBest', String(bestScore));
        }
        // Speed up slightly
        speed = Math.max(MIN_SPEED, BASE_SPEED - Math.floor(score / 50) * 10);
        placeFood();
      } else {
        snake.pop();
      }
    }

    function gameOver() {
      gameState = 'over';
    }

    function draw() {
      // Background
      ctx.fillStyle = '#16213e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid lines (subtle)
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * GRID, 0);
        ctx.lineTo(x * GRID, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * GRID);
        ctx.lineTo(canvas.width, y * GRID);
        ctx.stroke();
      }

      // Food
      ctx.fillStyle = '#ff6b6b';
      ctx.shadowColor = '#ff6b6b';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(
        food.x * GRID + GRID / 2,
        food.y * GRID + GRID / 2,
        GRID / 2 - 2,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.shadowBlur = 0;

      // Snake
      snake.forEach((seg, i) => {
        const ratio = 1 - i / snake.length;
        const g = Math.floor(180 + 75 * ratio);
        ctx.fillStyle = i === 0 ? '#00ff88' : `rgb(0, ${g}, ${Math.floor(60 + 56 * ratio)})`;
        ctx.shadowColor = i === 0 ? '#00ff88' : 'transparent';
        ctx.shadowBlur = i === 0 ? 8 : 0;

        const padding = 1;
        ctx.beginPath();
        roundRect(
          ctx,
          seg.x * GRID + padding,
          seg.y * GRID + padding,
          GRID - padding * 2,
          GRID - padding * 2,
          4
        );
        ctx.fill();
      });
      ctx.shadowBlur = 0;

      // Overlays
      if (gameState === 'ready') {
        drawOverlay('Snake', 'Press any arrow key to start');
      } else if (gameState === 'paused') {
        drawOverlay('Paused', 'Press Space to resume');
      } else if (gameState === 'over') {
        drawOverlay('Game Over', `Score: ${score}  |  Press Enter to restart`);
      }
    }

    function drawOverlay(title, subtitle) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = '#00d474';
      ctx.font = 'bold 36px Segoe UI, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(title, canvas.width / 2, canvas.height / 2 - 10);

      ctx.fillStyle = '#aaa';
      ctx.font = '16px Segoe UI, sans-serif';
      ctx.fillText(subtitle, canvas.width / 2, canvas.height / 2 + 25);
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
    }

    function setDirection(dx, dy) {
      // Prevent 180-degree turns
      if (direction.x === -dx && direction.y === -dy) return;
      if (dx !== 0 || dy !== 0) {
        nextDirection = { x: dx, y: dy };
      }
      if (gameState === 'ready') {
        gameState = 'playing';
      }
    }

    // Keyboard input
    document.addEventListener('keydown', (e) => {
      switch (e.key) {
        case 'ArrowUp': case 'w': case 'W':
          e.preventDefault();
          setDirection(0, -1);
          break;
        case 'ArrowDown': case 's': case 'S':
          e.preventDefault();
          setDirection(0, 1);
          break;
        case 'ArrowLeft': case 'a': case 'A':
          e.preventDefault();
          setDirection(-1, 0);
          break;
        case 'ArrowRight': case 'd': case 'D':
          e.preventDefault();
          setDirection(1, 0);
          break;
        case ' ':
          e.preventDefault();
          if (gameState === 'playing') gameState = 'paused';
          else if (gameState === 'paused') gameState = 'playing';
          break;
        case 'Enter':
          if (gameState === 'over') init();
          break;
      }
    });

    // Touch controls
    document.querySelectorAll('.touch-btn').forEach(btn => {
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const dir = btn.dataset.dir;
        if (dir === 'up') setDirection(0, -1);
        else if (dir === 'down') setDirection(0, 1);
        else if (dir === 'left') setDirection(-1, 0);
        else if (dir === 'right') setDirection(1, 0);
      });
    });

    // Game loop
    let lastTime = 0;
    function gameLoop(timestamp) {
      if (timestamp - lastTime >= speed) {
        update();
        lastTime = timestamp;
      }
      draw();
      requestAnimationFrame(gameLoop);
    }

    init();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
